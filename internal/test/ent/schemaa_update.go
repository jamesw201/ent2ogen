// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/dialect/sql/sqljson"
	"entgo.io/ent/schema/field"
	"github.com/ogen-go/ent2ogen/internal/test/ent/predicate"
	"github.com/ogen-go/ent2ogen/internal/test/ent/schemaa"
	"github.com/ogen-go/ent2ogen/internal/test/ent/schemab"
)

// SchemaAUpdate is the builder for updating SchemaA entities.
type SchemaAUpdate struct {
	config
	hooks    []Hook
	mutation *SchemaAMutation
}

// Where appends a list predicates to the SchemaAUpdate builder.
func (sa *SchemaAUpdate) Where(ps ...predicate.SchemaA) *SchemaAUpdate {
	sa.mutation.Where(ps...)
	return sa
}

// SetInt64 sets the "int64" field.
func (sa *SchemaAUpdate) SetInt64(i int64) *SchemaAUpdate {
	sa.mutation.ResetInt64()
	sa.mutation.SetInt64(i)
	return sa
}

// AddInt64 adds i to the "int64" field.
func (sa *SchemaAUpdate) AddInt64(i int64) *SchemaAUpdate {
	sa.mutation.AddInt64(i)
	return sa
}

// SetStringBindtoFoobar sets the "string_bindto_foobar" field.
func (sa *SchemaAUpdate) SetStringBindtoFoobar(s string) *SchemaAUpdate {
	sa.mutation.SetStringBindtoFoobar(s)
	return sa
}

// SetStringOptionalNullable sets the "string_optional_nullable" field.
func (sa *SchemaAUpdate) SetStringOptionalNullable(s string) *SchemaAUpdate {
	sa.mutation.SetStringOptionalNullable(s)
	return sa
}

// SetNillableStringOptionalNullable sets the "string_optional_nullable" field if the given value is not nil.
func (sa *SchemaAUpdate) SetNillableStringOptionalNullable(s *string) *SchemaAUpdate {
	if s != nil {
		sa.SetStringOptionalNullable(*s)
	}
	return sa
}

// ClearStringOptionalNullable clears the value of the "string_optional_nullable" field.
func (sa *SchemaAUpdate) ClearStringOptionalNullable() *SchemaAUpdate {
	sa.mutation.ClearStringOptionalNullable()
	return sa
}

// SetOptionalNullableBool sets the "optional_nullable_bool" field.
func (sa *SchemaAUpdate) SetOptionalNullableBool(b bool) *SchemaAUpdate {
	sa.mutation.SetOptionalNullableBool(b)
	return sa
}

// SetNillableOptionalNullableBool sets the "optional_nullable_bool" field if the given value is not nil.
func (sa *SchemaAUpdate) SetNillableOptionalNullableBool(b *bool) *SchemaAUpdate {
	if b != nil {
		sa.SetOptionalNullableBool(*b)
	}
	return sa
}

// ClearOptionalNullableBool clears the value of the "optional_nullable_bool" field.
func (sa *SchemaAUpdate) ClearOptionalNullableBool() *SchemaAUpdate {
	sa.mutation.ClearOptionalNullableBool()
	return sa
}

// SetJsontypeStrings sets the "jsontype_strings" field.
func (sa *SchemaAUpdate) SetJsontypeStrings(s []string) *SchemaAUpdate {
	sa.mutation.SetJsontypeStrings(s)
	return sa
}

// AppendJsontypeStrings appends s to the "jsontype_strings" field.
func (sa *SchemaAUpdate) AppendJsontypeStrings(s []string) *SchemaAUpdate {
	sa.mutation.AppendJsontypeStrings(s)
	return sa
}

// SetJsontypeStringsOptional sets the "jsontype_strings_optional" field.
func (sa *SchemaAUpdate) SetJsontypeStringsOptional(s []string) *SchemaAUpdate {
	sa.mutation.SetJsontypeStringsOptional(s)
	return sa
}

// AppendJsontypeStringsOptional appends s to the "jsontype_strings_optional" field.
func (sa *SchemaAUpdate) AppendJsontypeStringsOptional(s []string) *SchemaAUpdate {
	sa.mutation.AppendJsontypeStringsOptional(s)
	return sa
}

// ClearJsontypeStringsOptional clears the value of the "jsontype_strings_optional" field.
func (sa *SchemaAUpdate) ClearJsontypeStringsOptional() *SchemaAUpdate {
	sa.mutation.ClearJsontypeStringsOptional()
	return sa
}

// SetJsontypeInts sets the "jsontype_ints" field.
func (sa *SchemaAUpdate) SetJsontypeInts(i []int) *SchemaAUpdate {
	sa.mutation.SetJsontypeInts(i)
	return sa
}

// AppendJsontypeInts appends i to the "jsontype_ints" field.
func (sa *SchemaAUpdate) AppendJsontypeInts(i []int) *SchemaAUpdate {
	sa.mutation.AppendJsontypeInts(i)
	return sa
}

// SetJsontypeIntsOptional sets the "jsontype_ints_optional" field.
func (sa *SchemaAUpdate) SetJsontypeIntsOptional(i []int) *SchemaAUpdate {
	sa.mutation.SetJsontypeIntsOptional(i)
	return sa
}

// AppendJsontypeIntsOptional appends i to the "jsontype_ints_optional" field.
func (sa *SchemaAUpdate) AppendJsontypeIntsOptional(i []int) *SchemaAUpdate {
	sa.mutation.AppendJsontypeIntsOptional(i)
	return sa
}

// ClearJsontypeIntsOptional clears the value of the "jsontype_ints_optional" field.
func (sa *SchemaAUpdate) ClearJsontypeIntsOptional() *SchemaAUpdate {
	sa.mutation.ClearJsontypeIntsOptional()
	return sa
}

// SetRequiredEnum sets the "required_enum" field.
func (sa *SchemaAUpdate) SetRequiredEnum(se schemaa.RequiredEnum) *SchemaAUpdate {
	sa.mutation.SetRequiredEnum(se)
	return sa
}

// SetOptionalNullableEnum sets the "optional_nullable_enum" field.
func (sa *SchemaAUpdate) SetOptionalNullableEnum(sne schemaa.OptionalNullableEnum) *SchemaAUpdate {
	sa.mutation.SetOptionalNullableEnum(sne)
	return sa
}

// SetNillableOptionalNullableEnum sets the "optional_nullable_enum" field if the given value is not nil.
func (sa *SchemaAUpdate) SetNillableOptionalNullableEnum(sne *schemaa.OptionalNullableEnum) *SchemaAUpdate {
	if sne != nil {
		sa.SetOptionalNullableEnum(*sne)
	}
	return sa
}

// ClearOptionalNullableEnum clears the value of the "optional_nullable_enum" field.
func (sa *SchemaAUpdate) ClearOptionalNullableEnum() *SchemaAUpdate {
	sa.mutation.ClearOptionalNullableEnum()
	return sa
}

// SetBytes sets the "bytes" field.
func (sa *SchemaAUpdate) SetBytes(b []byte) *SchemaAUpdate {
	sa.mutation.SetBytes(b)
	return sa
}

// SetEdgeSchemabUniqueRequiredID sets the "edge_schemab_unique_required" edge to the SchemaB entity by ID.
func (sa *SchemaAUpdate) SetEdgeSchemabUniqueRequiredID(id int64) *SchemaAUpdate {
	sa.mutation.SetEdgeSchemabUniqueRequiredID(id)
	return sa
}

// SetEdgeSchemabUniqueRequired sets the "edge_schemab_unique_required" edge to the SchemaB entity.
func (sa *SchemaAUpdate) SetEdgeSchemabUniqueRequired(s *SchemaB) *SchemaAUpdate {
	return sa.SetEdgeSchemabUniqueRequiredID(s.ID)
}

// SetEdgeSchemabUniqueRequiredBindtoBsID sets the "edge_schemab_unique_required_bindto_bs" edge to the SchemaB entity by ID.
func (sa *SchemaAUpdate) SetEdgeSchemabUniqueRequiredBindtoBsID(id int64) *SchemaAUpdate {
	sa.mutation.SetEdgeSchemabUniqueRequiredBindtoBsID(id)
	return sa
}

// SetEdgeSchemabUniqueRequiredBindtoBs sets the "edge_schemab_unique_required_bindto_bs" edge to the SchemaB entity.
func (sa *SchemaAUpdate) SetEdgeSchemabUniqueRequiredBindtoBs(s *SchemaB) *SchemaAUpdate {
	return sa.SetEdgeSchemabUniqueRequiredBindtoBsID(s.ID)
}

// SetEdgeSchemabUniqueOptionalID sets the "edge_schemab_unique_optional" edge to the SchemaB entity by ID.
func (sa *SchemaAUpdate) SetEdgeSchemabUniqueOptionalID(id int64) *SchemaAUpdate {
	sa.mutation.SetEdgeSchemabUniqueOptionalID(id)
	return sa
}

// SetNillableEdgeSchemabUniqueOptionalID sets the "edge_schemab_unique_optional" edge to the SchemaB entity by ID if the given value is not nil.
func (sa *SchemaAUpdate) SetNillableEdgeSchemabUniqueOptionalID(id *int64) *SchemaAUpdate {
	if id != nil {
		sa = sa.SetEdgeSchemabUniqueOptionalID(*id)
	}
	return sa
}

// SetEdgeSchemabUniqueOptional sets the "edge_schemab_unique_optional" edge to the SchemaB entity.
func (sa *SchemaAUpdate) SetEdgeSchemabUniqueOptional(s *SchemaB) *SchemaAUpdate {
	return sa.SetEdgeSchemabUniqueOptionalID(s.ID)
}

// AddEdgeSchemabIDs adds the "edge_schemab" edge to the SchemaB entity by IDs.
func (sa *SchemaAUpdate) AddEdgeSchemabIDs(ids ...int64) *SchemaAUpdate {
	sa.mutation.AddEdgeSchemabIDs(ids...)
	return sa
}

// AddEdgeSchemab adds the "edge_schemab" edges to the SchemaB entity.
func (sa *SchemaAUpdate) AddEdgeSchemab(s ...*SchemaB) *SchemaAUpdate {
	ids := make([]int64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return sa.AddEdgeSchemabIDs(ids...)
}

// AddEdgeSchemaaRecursiveIDs adds the "edge_schemaa_recursive" edge to the SchemaA entity by IDs.
func (sa *SchemaAUpdate) AddEdgeSchemaaRecursiveIDs(ids ...int) *SchemaAUpdate {
	sa.mutation.AddEdgeSchemaaRecursiveIDs(ids...)
	return sa
}

// AddEdgeSchemaaRecursive adds the "edge_schemaa_recursive" edges to the SchemaA entity.
func (sa *SchemaAUpdate) AddEdgeSchemaaRecursive(s ...*SchemaA) *SchemaAUpdate {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return sa.AddEdgeSchemaaRecursiveIDs(ids...)
}

// Mutation returns the SchemaAMutation object of the builder.
func (sa *SchemaAUpdate) Mutation() *SchemaAMutation {
	return sa.mutation
}

// ClearEdgeSchemabUniqueRequired clears the "edge_schemab_unique_required" edge to the SchemaB entity.
func (sa *SchemaAUpdate) ClearEdgeSchemabUniqueRequired() *SchemaAUpdate {
	sa.mutation.ClearEdgeSchemabUniqueRequired()
	return sa
}

// ClearEdgeSchemabUniqueRequiredBindtoBs clears the "edge_schemab_unique_required_bindto_bs" edge to the SchemaB entity.
func (sa *SchemaAUpdate) ClearEdgeSchemabUniqueRequiredBindtoBs() *SchemaAUpdate {
	sa.mutation.ClearEdgeSchemabUniqueRequiredBindtoBs()
	return sa
}

// ClearEdgeSchemabUniqueOptional clears the "edge_schemab_unique_optional" edge to the SchemaB entity.
func (sa *SchemaAUpdate) ClearEdgeSchemabUniqueOptional() *SchemaAUpdate {
	sa.mutation.ClearEdgeSchemabUniqueOptional()
	return sa
}

// ClearEdgeSchemab clears all "edge_schemab" edges to the SchemaB entity.
func (sa *SchemaAUpdate) ClearEdgeSchemab() *SchemaAUpdate {
	sa.mutation.ClearEdgeSchemab()
	return sa
}

// RemoveEdgeSchemabIDs removes the "edge_schemab" edge to SchemaB entities by IDs.
func (sa *SchemaAUpdate) RemoveEdgeSchemabIDs(ids ...int64) *SchemaAUpdate {
	sa.mutation.RemoveEdgeSchemabIDs(ids...)
	return sa
}

// RemoveEdgeSchemab removes "edge_schemab" edges to SchemaB entities.
func (sa *SchemaAUpdate) RemoveEdgeSchemab(s ...*SchemaB) *SchemaAUpdate {
	ids := make([]int64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return sa.RemoveEdgeSchemabIDs(ids...)
}

// ClearEdgeSchemaaRecursive clears all "edge_schemaa_recursive" edges to the SchemaA entity.
func (sa *SchemaAUpdate) ClearEdgeSchemaaRecursive() *SchemaAUpdate {
	sa.mutation.ClearEdgeSchemaaRecursive()
	return sa
}

// RemoveEdgeSchemaaRecursiveIDs removes the "edge_schemaa_recursive" edge to SchemaA entities by IDs.
func (sa *SchemaAUpdate) RemoveEdgeSchemaaRecursiveIDs(ids ...int) *SchemaAUpdate {
	sa.mutation.RemoveEdgeSchemaaRecursiveIDs(ids...)
	return sa
}

// RemoveEdgeSchemaaRecursive removes "edge_schemaa_recursive" edges to SchemaA entities.
func (sa *SchemaAUpdate) RemoveEdgeSchemaaRecursive(s ...*SchemaA) *SchemaAUpdate {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return sa.RemoveEdgeSchemaaRecursiveIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (sa *SchemaAUpdate) Save(ctx context.Context) (int, error) {
	return withHooks[int, SchemaAMutation](ctx, sa.sqlSave, sa.mutation, sa.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (sa *SchemaAUpdate) SaveX(ctx context.Context) int {
	affected, err := sa.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (sa *SchemaAUpdate) Exec(ctx context.Context) error {
	_, err := sa.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (sa *SchemaAUpdate) ExecX(ctx context.Context) {
	if err := sa.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (sa *SchemaAUpdate) check() error {
	if v, ok := sa.mutation.RequiredEnum(); ok {
		if err := schemaa.RequiredEnumValidator(v); err != nil {
			return &ValidationError{Name: "required_enum", err: fmt.Errorf(`ent: validator failed for field "SchemaA.required_enum": %w`, err)}
		}
	}
	if v, ok := sa.mutation.OptionalNullableEnum(); ok {
		if err := schemaa.OptionalNullableEnumValidator(v); err != nil {
			return &ValidationError{Name: "optional_nullable_enum", err: fmt.Errorf(`ent: validator failed for field "SchemaA.optional_nullable_enum": %w`, err)}
		}
	}
	if _, ok := sa.mutation.EdgeSchemabUniqueRequiredID(); sa.mutation.EdgeSchemabUniqueRequiredCleared() && !ok {
		return errors.New(`ent: clearing a required unique edge "SchemaA.edge_schemab_unique_required"`)
	}
	if _, ok := sa.mutation.EdgeSchemabUniqueRequiredBindtoBsID(); sa.mutation.EdgeSchemabUniqueRequiredBindtoBsCleared() && !ok {
		return errors.New(`ent: clearing a required unique edge "SchemaA.edge_schemab_unique_required_bindto_bs"`)
	}
	return nil
}

func (sa *SchemaAUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := sa.check(); err != nil {
		return n, err
	}
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   schemaa.Table,
			Columns: schemaa.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: schemaa.FieldID,
			},
		},
	}
	if ps := sa.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := sa.mutation.Int64(); ok {
		_spec.SetField(schemaa.FieldInt64, field.TypeInt64, value)
	}
	if value, ok := sa.mutation.AddedInt64(); ok {
		_spec.AddField(schemaa.FieldInt64, field.TypeInt64, value)
	}
	if value, ok := sa.mutation.StringBindtoFoobar(); ok {
		_spec.SetField(schemaa.FieldStringBindtoFoobar, field.TypeString, value)
	}
	if value, ok := sa.mutation.StringOptionalNullable(); ok {
		_spec.SetField(schemaa.FieldStringOptionalNullable, field.TypeString, value)
	}
	if sa.mutation.StringOptionalNullableCleared() {
		_spec.ClearField(schemaa.FieldStringOptionalNullable, field.TypeString)
	}
	if value, ok := sa.mutation.OptionalNullableBool(); ok {
		_spec.SetField(schemaa.FieldOptionalNullableBool, field.TypeBool, value)
	}
	if sa.mutation.OptionalNullableBoolCleared() {
		_spec.ClearField(schemaa.FieldOptionalNullableBool, field.TypeBool)
	}
	if value, ok := sa.mutation.JsontypeStrings(); ok {
		_spec.SetField(schemaa.FieldJsontypeStrings, field.TypeJSON, value)
	}
	if value, ok := sa.mutation.AppendedJsontypeStrings(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, schemaa.FieldJsontypeStrings, value)
		})
	}
	if value, ok := sa.mutation.JsontypeStringsOptional(); ok {
		_spec.SetField(schemaa.FieldJsontypeStringsOptional, field.TypeJSON, value)
	}
	if value, ok := sa.mutation.AppendedJsontypeStringsOptional(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, schemaa.FieldJsontypeStringsOptional, value)
		})
	}
	if sa.mutation.JsontypeStringsOptionalCleared() {
		_spec.ClearField(schemaa.FieldJsontypeStringsOptional, field.TypeJSON)
	}
	if value, ok := sa.mutation.JsontypeInts(); ok {
		_spec.SetField(schemaa.FieldJsontypeInts, field.TypeJSON, value)
	}
	if value, ok := sa.mutation.AppendedJsontypeInts(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, schemaa.FieldJsontypeInts, value)
		})
	}
	if value, ok := sa.mutation.JsontypeIntsOptional(); ok {
		_spec.SetField(schemaa.FieldJsontypeIntsOptional, field.TypeJSON, value)
	}
	if value, ok := sa.mutation.AppendedJsontypeIntsOptional(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, schemaa.FieldJsontypeIntsOptional, value)
		})
	}
	if sa.mutation.JsontypeIntsOptionalCleared() {
		_spec.ClearField(schemaa.FieldJsontypeIntsOptional, field.TypeJSON)
	}
	if value, ok := sa.mutation.RequiredEnum(); ok {
		_spec.SetField(schemaa.FieldRequiredEnum, field.TypeEnum, value)
	}
	if value, ok := sa.mutation.OptionalNullableEnum(); ok {
		_spec.SetField(schemaa.FieldOptionalNullableEnum, field.TypeEnum, value)
	}
	if sa.mutation.OptionalNullableEnumCleared() {
		_spec.ClearField(schemaa.FieldOptionalNullableEnum, field.TypeEnum)
	}
	if value, ok := sa.mutation.Bytes(); ok {
		_spec.SetField(schemaa.FieldBytes, field.TypeBytes, value)
	}
	if sa.mutation.EdgeSchemabUniqueRequiredCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   schemaa.EdgeSchemabUniqueRequiredTable,
			Columns: []string{schemaa.EdgeSchemabUniqueRequiredColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt64,
					Column: schemab.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := sa.mutation.EdgeSchemabUniqueRequiredIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   schemaa.EdgeSchemabUniqueRequiredTable,
			Columns: []string{schemaa.EdgeSchemabUniqueRequiredColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt64,
					Column: schemab.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if sa.mutation.EdgeSchemabUniqueRequiredBindtoBsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   schemaa.EdgeSchemabUniqueRequiredBindtoBsTable,
			Columns: []string{schemaa.EdgeSchemabUniqueRequiredBindtoBsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt64,
					Column: schemab.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := sa.mutation.EdgeSchemabUniqueRequiredBindtoBsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   schemaa.EdgeSchemabUniqueRequiredBindtoBsTable,
			Columns: []string{schemaa.EdgeSchemabUniqueRequiredBindtoBsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt64,
					Column: schemab.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if sa.mutation.EdgeSchemabUniqueOptionalCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   schemaa.EdgeSchemabUniqueOptionalTable,
			Columns: []string{schemaa.EdgeSchemabUniqueOptionalColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt64,
					Column: schemab.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := sa.mutation.EdgeSchemabUniqueOptionalIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   schemaa.EdgeSchemabUniqueOptionalTable,
			Columns: []string{schemaa.EdgeSchemabUniqueOptionalColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt64,
					Column: schemab.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if sa.mutation.EdgeSchemabCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   schemaa.EdgeSchemabTable,
			Columns: []string{schemaa.EdgeSchemabColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt64,
					Column: schemab.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := sa.mutation.RemovedEdgeSchemabIDs(); len(nodes) > 0 && !sa.mutation.EdgeSchemabCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   schemaa.EdgeSchemabTable,
			Columns: []string{schemaa.EdgeSchemabColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt64,
					Column: schemab.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := sa.mutation.EdgeSchemabIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   schemaa.EdgeSchemabTable,
			Columns: []string{schemaa.EdgeSchemabColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt64,
					Column: schemab.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if sa.mutation.EdgeSchemaaRecursiveCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   schemaa.EdgeSchemaaRecursiveTable,
			Columns: schemaa.EdgeSchemaaRecursivePrimaryKey,
			Bidi:    true,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: schemaa.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := sa.mutation.RemovedEdgeSchemaaRecursiveIDs(); len(nodes) > 0 && !sa.mutation.EdgeSchemaaRecursiveCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   schemaa.EdgeSchemaaRecursiveTable,
			Columns: schemaa.EdgeSchemaaRecursivePrimaryKey,
			Bidi:    true,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: schemaa.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := sa.mutation.EdgeSchemaaRecursiveIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   schemaa.EdgeSchemaaRecursiveTable,
			Columns: schemaa.EdgeSchemaaRecursivePrimaryKey,
			Bidi:    true,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: schemaa.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, sa.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{schemaa.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	sa.mutation.done = true
	return n, nil
}

// SchemaAUpdateOne is the builder for updating a single SchemaA entity.
type SchemaAUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *SchemaAMutation
}

// SetInt64 sets the "int64" field.
func (sao *SchemaAUpdateOne) SetInt64(i int64) *SchemaAUpdateOne {
	sao.mutation.ResetInt64()
	sao.mutation.SetInt64(i)
	return sao
}

// AddInt64 adds i to the "int64" field.
func (sao *SchemaAUpdateOne) AddInt64(i int64) *SchemaAUpdateOne {
	sao.mutation.AddInt64(i)
	return sao
}

// SetStringBindtoFoobar sets the "string_bindto_foobar" field.
func (sao *SchemaAUpdateOne) SetStringBindtoFoobar(s string) *SchemaAUpdateOne {
	sao.mutation.SetStringBindtoFoobar(s)
	return sao
}

// SetStringOptionalNullable sets the "string_optional_nullable" field.
func (sao *SchemaAUpdateOne) SetStringOptionalNullable(s string) *SchemaAUpdateOne {
	sao.mutation.SetStringOptionalNullable(s)
	return sao
}

// SetNillableStringOptionalNullable sets the "string_optional_nullable" field if the given value is not nil.
func (sao *SchemaAUpdateOne) SetNillableStringOptionalNullable(s *string) *SchemaAUpdateOne {
	if s != nil {
		sao.SetStringOptionalNullable(*s)
	}
	return sao
}

// ClearStringOptionalNullable clears the value of the "string_optional_nullable" field.
func (sao *SchemaAUpdateOne) ClearStringOptionalNullable() *SchemaAUpdateOne {
	sao.mutation.ClearStringOptionalNullable()
	return sao
}

// SetOptionalNullableBool sets the "optional_nullable_bool" field.
func (sao *SchemaAUpdateOne) SetOptionalNullableBool(b bool) *SchemaAUpdateOne {
	sao.mutation.SetOptionalNullableBool(b)
	return sao
}

// SetNillableOptionalNullableBool sets the "optional_nullable_bool" field if the given value is not nil.
func (sao *SchemaAUpdateOne) SetNillableOptionalNullableBool(b *bool) *SchemaAUpdateOne {
	if b != nil {
		sao.SetOptionalNullableBool(*b)
	}
	return sao
}

// ClearOptionalNullableBool clears the value of the "optional_nullable_bool" field.
func (sao *SchemaAUpdateOne) ClearOptionalNullableBool() *SchemaAUpdateOne {
	sao.mutation.ClearOptionalNullableBool()
	return sao
}

// SetJsontypeStrings sets the "jsontype_strings" field.
func (sao *SchemaAUpdateOne) SetJsontypeStrings(s []string) *SchemaAUpdateOne {
	sao.mutation.SetJsontypeStrings(s)
	return sao
}

// AppendJsontypeStrings appends s to the "jsontype_strings" field.
func (sao *SchemaAUpdateOne) AppendJsontypeStrings(s []string) *SchemaAUpdateOne {
	sao.mutation.AppendJsontypeStrings(s)
	return sao
}

// SetJsontypeStringsOptional sets the "jsontype_strings_optional" field.
func (sao *SchemaAUpdateOne) SetJsontypeStringsOptional(s []string) *SchemaAUpdateOne {
	sao.mutation.SetJsontypeStringsOptional(s)
	return sao
}

// AppendJsontypeStringsOptional appends s to the "jsontype_strings_optional" field.
func (sao *SchemaAUpdateOne) AppendJsontypeStringsOptional(s []string) *SchemaAUpdateOne {
	sao.mutation.AppendJsontypeStringsOptional(s)
	return sao
}

// ClearJsontypeStringsOptional clears the value of the "jsontype_strings_optional" field.
func (sao *SchemaAUpdateOne) ClearJsontypeStringsOptional() *SchemaAUpdateOne {
	sao.mutation.ClearJsontypeStringsOptional()
	return sao
}

// SetJsontypeInts sets the "jsontype_ints" field.
func (sao *SchemaAUpdateOne) SetJsontypeInts(i []int) *SchemaAUpdateOne {
	sao.mutation.SetJsontypeInts(i)
	return sao
}

// AppendJsontypeInts appends i to the "jsontype_ints" field.
func (sao *SchemaAUpdateOne) AppendJsontypeInts(i []int) *SchemaAUpdateOne {
	sao.mutation.AppendJsontypeInts(i)
	return sao
}

// SetJsontypeIntsOptional sets the "jsontype_ints_optional" field.
func (sao *SchemaAUpdateOne) SetJsontypeIntsOptional(i []int) *SchemaAUpdateOne {
	sao.mutation.SetJsontypeIntsOptional(i)
	return sao
}

// AppendJsontypeIntsOptional appends i to the "jsontype_ints_optional" field.
func (sao *SchemaAUpdateOne) AppendJsontypeIntsOptional(i []int) *SchemaAUpdateOne {
	sao.mutation.AppendJsontypeIntsOptional(i)
	return sao
}

// ClearJsontypeIntsOptional clears the value of the "jsontype_ints_optional" field.
func (sao *SchemaAUpdateOne) ClearJsontypeIntsOptional() *SchemaAUpdateOne {
	sao.mutation.ClearJsontypeIntsOptional()
	return sao
}

// SetRequiredEnum sets the "required_enum" field.
func (sao *SchemaAUpdateOne) SetRequiredEnum(se schemaa.RequiredEnum) *SchemaAUpdateOne {
	sao.mutation.SetRequiredEnum(se)
	return sao
}

// SetOptionalNullableEnum sets the "optional_nullable_enum" field.
func (sao *SchemaAUpdateOne) SetOptionalNullableEnum(sne schemaa.OptionalNullableEnum) *SchemaAUpdateOne {
	sao.mutation.SetOptionalNullableEnum(sne)
	return sao
}

// SetNillableOptionalNullableEnum sets the "optional_nullable_enum" field if the given value is not nil.
func (sao *SchemaAUpdateOne) SetNillableOptionalNullableEnum(sne *schemaa.OptionalNullableEnum) *SchemaAUpdateOne {
	if sne != nil {
		sao.SetOptionalNullableEnum(*sne)
	}
	return sao
}

// ClearOptionalNullableEnum clears the value of the "optional_nullable_enum" field.
func (sao *SchemaAUpdateOne) ClearOptionalNullableEnum() *SchemaAUpdateOne {
	sao.mutation.ClearOptionalNullableEnum()
	return sao
}

// SetBytes sets the "bytes" field.
func (sao *SchemaAUpdateOne) SetBytes(b []byte) *SchemaAUpdateOne {
	sao.mutation.SetBytes(b)
	return sao
}

// SetEdgeSchemabUniqueRequiredID sets the "edge_schemab_unique_required" edge to the SchemaB entity by ID.
func (sao *SchemaAUpdateOne) SetEdgeSchemabUniqueRequiredID(id int64) *SchemaAUpdateOne {
	sao.mutation.SetEdgeSchemabUniqueRequiredID(id)
	return sao
}

// SetEdgeSchemabUniqueRequired sets the "edge_schemab_unique_required" edge to the SchemaB entity.
func (sao *SchemaAUpdateOne) SetEdgeSchemabUniqueRequired(s *SchemaB) *SchemaAUpdateOne {
	return sao.SetEdgeSchemabUniqueRequiredID(s.ID)
}

// SetEdgeSchemabUniqueRequiredBindtoBsID sets the "edge_schemab_unique_required_bindto_bs" edge to the SchemaB entity by ID.
func (sao *SchemaAUpdateOne) SetEdgeSchemabUniqueRequiredBindtoBsID(id int64) *SchemaAUpdateOne {
	sao.mutation.SetEdgeSchemabUniqueRequiredBindtoBsID(id)
	return sao
}

// SetEdgeSchemabUniqueRequiredBindtoBs sets the "edge_schemab_unique_required_bindto_bs" edge to the SchemaB entity.
func (sao *SchemaAUpdateOne) SetEdgeSchemabUniqueRequiredBindtoBs(s *SchemaB) *SchemaAUpdateOne {
	return sao.SetEdgeSchemabUniqueRequiredBindtoBsID(s.ID)
}

// SetEdgeSchemabUniqueOptionalID sets the "edge_schemab_unique_optional" edge to the SchemaB entity by ID.
func (sao *SchemaAUpdateOne) SetEdgeSchemabUniqueOptionalID(id int64) *SchemaAUpdateOne {
	sao.mutation.SetEdgeSchemabUniqueOptionalID(id)
	return sao
}

// SetNillableEdgeSchemabUniqueOptionalID sets the "edge_schemab_unique_optional" edge to the SchemaB entity by ID if the given value is not nil.
func (sao *SchemaAUpdateOne) SetNillableEdgeSchemabUniqueOptionalID(id *int64) *SchemaAUpdateOne {
	if id != nil {
		sao = sao.SetEdgeSchemabUniqueOptionalID(*id)
	}
	return sao
}

// SetEdgeSchemabUniqueOptional sets the "edge_schemab_unique_optional" edge to the SchemaB entity.
func (sao *SchemaAUpdateOne) SetEdgeSchemabUniqueOptional(s *SchemaB) *SchemaAUpdateOne {
	return sao.SetEdgeSchemabUniqueOptionalID(s.ID)
}

// AddEdgeSchemabIDs adds the "edge_schemab" edge to the SchemaB entity by IDs.
func (sao *SchemaAUpdateOne) AddEdgeSchemabIDs(ids ...int64) *SchemaAUpdateOne {
	sao.mutation.AddEdgeSchemabIDs(ids...)
	return sao
}

// AddEdgeSchemab adds the "edge_schemab" edges to the SchemaB entity.
func (sao *SchemaAUpdateOne) AddEdgeSchemab(s ...*SchemaB) *SchemaAUpdateOne {
	ids := make([]int64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return sao.AddEdgeSchemabIDs(ids...)
}

// AddEdgeSchemaaRecursiveIDs adds the "edge_schemaa_recursive" edge to the SchemaA entity by IDs.
func (sao *SchemaAUpdateOne) AddEdgeSchemaaRecursiveIDs(ids ...int) *SchemaAUpdateOne {
	sao.mutation.AddEdgeSchemaaRecursiveIDs(ids...)
	return sao
}

// AddEdgeSchemaaRecursive adds the "edge_schemaa_recursive" edges to the SchemaA entity.
func (sao *SchemaAUpdateOne) AddEdgeSchemaaRecursive(s ...*SchemaA) *SchemaAUpdateOne {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return sao.AddEdgeSchemaaRecursiveIDs(ids...)
}

// Mutation returns the SchemaAMutation object of the builder.
func (sao *SchemaAUpdateOne) Mutation() *SchemaAMutation {
	return sao.mutation
}

// ClearEdgeSchemabUniqueRequired clears the "edge_schemab_unique_required" edge to the SchemaB entity.
func (sao *SchemaAUpdateOne) ClearEdgeSchemabUniqueRequired() *SchemaAUpdateOne {
	sao.mutation.ClearEdgeSchemabUniqueRequired()
	return sao
}

// ClearEdgeSchemabUniqueRequiredBindtoBs clears the "edge_schemab_unique_required_bindto_bs" edge to the SchemaB entity.
func (sao *SchemaAUpdateOne) ClearEdgeSchemabUniqueRequiredBindtoBs() *SchemaAUpdateOne {
	sao.mutation.ClearEdgeSchemabUniqueRequiredBindtoBs()
	return sao
}

// ClearEdgeSchemabUniqueOptional clears the "edge_schemab_unique_optional" edge to the SchemaB entity.
func (sao *SchemaAUpdateOne) ClearEdgeSchemabUniqueOptional() *SchemaAUpdateOne {
	sao.mutation.ClearEdgeSchemabUniqueOptional()
	return sao
}

// ClearEdgeSchemab clears all "edge_schemab" edges to the SchemaB entity.
func (sao *SchemaAUpdateOne) ClearEdgeSchemab() *SchemaAUpdateOne {
	sao.mutation.ClearEdgeSchemab()
	return sao
}

// RemoveEdgeSchemabIDs removes the "edge_schemab" edge to SchemaB entities by IDs.
func (sao *SchemaAUpdateOne) RemoveEdgeSchemabIDs(ids ...int64) *SchemaAUpdateOne {
	sao.mutation.RemoveEdgeSchemabIDs(ids...)
	return sao
}

// RemoveEdgeSchemab removes "edge_schemab" edges to SchemaB entities.
func (sao *SchemaAUpdateOne) RemoveEdgeSchemab(s ...*SchemaB) *SchemaAUpdateOne {
	ids := make([]int64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return sao.RemoveEdgeSchemabIDs(ids...)
}

// ClearEdgeSchemaaRecursive clears all "edge_schemaa_recursive" edges to the SchemaA entity.
func (sao *SchemaAUpdateOne) ClearEdgeSchemaaRecursive() *SchemaAUpdateOne {
	sao.mutation.ClearEdgeSchemaaRecursive()
	return sao
}

// RemoveEdgeSchemaaRecursiveIDs removes the "edge_schemaa_recursive" edge to SchemaA entities by IDs.
func (sao *SchemaAUpdateOne) RemoveEdgeSchemaaRecursiveIDs(ids ...int) *SchemaAUpdateOne {
	sao.mutation.RemoveEdgeSchemaaRecursiveIDs(ids...)
	return sao
}

// RemoveEdgeSchemaaRecursive removes "edge_schemaa_recursive" edges to SchemaA entities.
func (sao *SchemaAUpdateOne) RemoveEdgeSchemaaRecursive(s ...*SchemaA) *SchemaAUpdateOne {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return sao.RemoveEdgeSchemaaRecursiveIDs(ids...)
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (sao *SchemaAUpdateOne) Select(field string, fields ...string) *SchemaAUpdateOne {
	sao.fields = append([]string{field}, fields...)
	return sao
}

// Save executes the query and returns the updated SchemaA entity.
func (sao *SchemaAUpdateOne) Save(ctx context.Context) (*SchemaA, error) {
	return withHooks[*SchemaA, SchemaAMutation](ctx, sao.sqlSave, sao.mutation, sao.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (sao *SchemaAUpdateOne) SaveX(ctx context.Context) *SchemaA {
	node, err := sao.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (sao *SchemaAUpdateOne) Exec(ctx context.Context) error {
	_, err := sao.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (sao *SchemaAUpdateOne) ExecX(ctx context.Context) {
	if err := sao.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (sao *SchemaAUpdateOne) check() error {
	if v, ok := sao.mutation.RequiredEnum(); ok {
		if err := schemaa.RequiredEnumValidator(v); err != nil {
			return &ValidationError{Name: "required_enum", err: fmt.Errorf(`ent: validator failed for field "SchemaA.required_enum": %w`, err)}
		}
	}
	if v, ok := sao.mutation.OptionalNullableEnum(); ok {
		if err := schemaa.OptionalNullableEnumValidator(v); err != nil {
			return &ValidationError{Name: "optional_nullable_enum", err: fmt.Errorf(`ent: validator failed for field "SchemaA.optional_nullable_enum": %w`, err)}
		}
	}
	if _, ok := sao.mutation.EdgeSchemabUniqueRequiredID(); sao.mutation.EdgeSchemabUniqueRequiredCleared() && !ok {
		return errors.New(`ent: clearing a required unique edge "SchemaA.edge_schemab_unique_required"`)
	}
	if _, ok := sao.mutation.EdgeSchemabUniqueRequiredBindtoBsID(); sao.mutation.EdgeSchemabUniqueRequiredBindtoBsCleared() && !ok {
		return errors.New(`ent: clearing a required unique edge "SchemaA.edge_schemab_unique_required_bindto_bs"`)
	}
	return nil
}

func (sao *SchemaAUpdateOne) sqlSave(ctx context.Context) (_node *SchemaA, err error) {
	if err := sao.check(); err != nil {
		return _node, err
	}
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   schemaa.Table,
			Columns: schemaa.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: schemaa.FieldID,
			},
		},
	}
	id, ok := sao.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "SchemaA.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := sao.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, schemaa.FieldID)
		for _, f := range fields {
			if !schemaa.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != schemaa.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := sao.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := sao.mutation.Int64(); ok {
		_spec.SetField(schemaa.FieldInt64, field.TypeInt64, value)
	}
	if value, ok := sao.mutation.AddedInt64(); ok {
		_spec.AddField(schemaa.FieldInt64, field.TypeInt64, value)
	}
	if value, ok := sao.mutation.StringBindtoFoobar(); ok {
		_spec.SetField(schemaa.FieldStringBindtoFoobar, field.TypeString, value)
	}
	if value, ok := sao.mutation.StringOptionalNullable(); ok {
		_spec.SetField(schemaa.FieldStringOptionalNullable, field.TypeString, value)
	}
	if sao.mutation.StringOptionalNullableCleared() {
		_spec.ClearField(schemaa.FieldStringOptionalNullable, field.TypeString)
	}
	if value, ok := sao.mutation.OptionalNullableBool(); ok {
		_spec.SetField(schemaa.FieldOptionalNullableBool, field.TypeBool, value)
	}
	if sao.mutation.OptionalNullableBoolCleared() {
		_spec.ClearField(schemaa.FieldOptionalNullableBool, field.TypeBool)
	}
	if value, ok := sao.mutation.JsontypeStrings(); ok {
		_spec.SetField(schemaa.FieldJsontypeStrings, field.TypeJSON, value)
	}
	if value, ok := sao.mutation.AppendedJsontypeStrings(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, schemaa.FieldJsontypeStrings, value)
		})
	}
	if value, ok := sao.mutation.JsontypeStringsOptional(); ok {
		_spec.SetField(schemaa.FieldJsontypeStringsOptional, field.TypeJSON, value)
	}
	if value, ok := sao.mutation.AppendedJsontypeStringsOptional(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, schemaa.FieldJsontypeStringsOptional, value)
		})
	}
	if sao.mutation.JsontypeStringsOptionalCleared() {
		_spec.ClearField(schemaa.FieldJsontypeStringsOptional, field.TypeJSON)
	}
	if value, ok := sao.mutation.JsontypeInts(); ok {
		_spec.SetField(schemaa.FieldJsontypeInts, field.TypeJSON, value)
	}
	if value, ok := sao.mutation.AppendedJsontypeInts(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, schemaa.FieldJsontypeInts, value)
		})
	}
	if value, ok := sao.mutation.JsontypeIntsOptional(); ok {
		_spec.SetField(schemaa.FieldJsontypeIntsOptional, field.TypeJSON, value)
	}
	if value, ok := sao.mutation.AppendedJsontypeIntsOptional(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, schemaa.FieldJsontypeIntsOptional, value)
		})
	}
	if sao.mutation.JsontypeIntsOptionalCleared() {
		_spec.ClearField(schemaa.FieldJsontypeIntsOptional, field.TypeJSON)
	}
	if value, ok := sao.mutation.RequiredEnum(); ok {
		_spec.SetField(schemaa.FieldRequiredEnum, field.TypeEnum, value)
	}
	if value, ok := sao.mutation.OptionalNullableEnum(); ok {
		_spec.SetField(schemaa.FieldOptionalNullableEnum, field.TypeEnum, value)
	}
	if sao.mutation.OptionalNullableEnumCleared() {
		_spec.ClearField(schemaa.FieldOptionalNullableEnum, field.TypeEnum)
	}
	if value, ok := sao.mutation.Bytes(); ok {
		_spec.SetField(schemaa.FieldBytes, field.TypeBytes, value)
	}
	if sao.mutation.EdgeSchemabUniqueRequiredCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   schemaa.EdgeSchemabUniqueRequiredTable,
			Columns: []string{schemaa.EdgeSchemabUniqueRequiredColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt64,
					Column: schemab.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := sao.mutation.EdgeSchemabUniqueRequiredIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   schemaa.EdgeSchemabUniqueRequiredTable,
			Columns: []string{schemaa.EdgeSchemabUniqueRequiredColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt64,
					Column: schemab.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if sao.mutation.EdgeSchemabUniqueRequiredBindtoBsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   schemaa.EdgeSchemabUniqueRequiredBindtoBsTable,
			Columns: []string{schemaa.EdgeSchemabUniqueRequiredBindtoBsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt64,
					Column: schemab.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := sao.mutation.EdgeSchemabUniqueRequiredBindtoBsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   schemaa.EdgeSchemabUniqueRequiredBindtoBsTable,
			Columns: []string{schemaa.EdgeSchemabUniqueRequiredBindtoBsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt64,
					Column: schemab.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if sao.mutation.EdgeSchemabUniqueOptionalCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   schemaa.EdgeSchemabUniqueOptionalTable,
			Columns: []string{schemaa.EdgeSchemabUniqueOptionalColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt64,
					Column: schemab.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := sao.mutation.EdgeSchemabUniqueOptionalIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   schemaa.EdgeSchemabUniqueOptionalTable,
			Columns: []string{schemaa.EdgeSchemabUniqueOptionalColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt64,
					Column: schemab.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if sao.mutation.EdgeSchemabCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   schemaa.EdgeSchemabTable,
			Columns: []string{schemaa.EdgeSchemabColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt64,
					Column: schemab.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := sao.mutation.RemovedEdgeSchemabIDs(); len(nodes) > 0 && !sao.mutation.EdgeSchemabCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   schemaa.EdgeSchemabTable,
			Columns: []string{schemaa.EdgeSchemabColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt64,
					Column: schemab.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := sao.mutation.EdgeSchemabIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   schemaa.EdgeSchemabTable,
			Columns: []string{schemaa.EdgeSchemabColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt64,
					Column: schemab.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if sao.mutation.EdgeSchemaaRecursiveCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   schemaa.EdgeSchemaaRecursiveTable,
			Columns: schemaa.EdgeSchemaaRecursivePrimaryKey,
			Bidi:    true,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: schemaa.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := sao.mutation.RemovedEdgeSchemaaRecursiveIDs(); len(nodes) > 0 && !sao.mutation.EdgeSchemaaRecursiveCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   schemaa.EdgeSchemaaRecursiveTable,
			Columns: schemaa.EdgeSchemaaRecursivePrimaryKey,
			Bidi:    true,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: schemaa.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := sao.mutation.EdgeSchemaaRecursiveIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   schemaa.EdgeSchemaaRecursiveTable,
			Columns: schemaa.EdgeSchemaaRecursivePrimaryKey,
			Bidi:    true,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: schemaa.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &SchemaA{config: sao.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, sao.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{schemaa.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	sao.mutation.done = true
	return _node, nil
}
